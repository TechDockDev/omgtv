import { PubSub, Message } from "@google-cloud/pubsub";
import { mkdir, rm } from "node:fs/promises";
import { join } from "node:path";
import { randomUUID } from "node:crypto";
import pino from "pino";
import { PrismaClient, MediaAssetStatus } from "@prisma/client"; // [NEW] Prisma
import { loadConfig } from "./config.js";
import { StorageClient } from "./storage.js";
import { FFmpegService } from "./ffmpeg.js";
import type { MediaUploadedMessage, MediaReadyEvent, TranscodeJob, MediaFailedEvent } from "./types.js";

const config = loadConfig();
const logger = pino({ level: config.LOG_LEVEL });

const storage = new StorageClient(config, logger);
const ffmpeg = new FFmpegService(config, logger);
const pubsub = new PubSub({ projectId: config.GCP_PROJECT_ID });
const prisma = new PrismaClient(); // [NEW] Init Prisma

/**
 * Main entry point for TranscodingWorker
 * Listens to Pub/Sub subscription and processes transcoding jobs
 */
async function main(): Promise<void> {
    logger.info({ config: { ...config, SERVICE_AUTH_TOKEN: "***" } }, "Starting TranscodingWorker");

    // Connect to DB
    try {
        await prisma.$connect();
        logger.info("Connected to Database");
    } catch (e) {
        logger.fatal({ error: e }, "Failed to connect to Database");
        process.exit(1);
    }

    const subscription = pubsub.subscription(config.PUBSUB_SUBSCRIPTION);

    logger.info(
        { subscription: config.PUBSUB_SUBSCRIPTION },
        "Listening for transcode jobs"
    );

    subscription.on("message", handleMessage);
    subscription.on("error", (error) => {
        logger.error({ error }, "Subscription error");
    });

    // Keep process alive
    process.on("SIGTERM", async () => {
        logger.info("Received SIGTERM, shutting down");
        await subscription.close();
        await prisma.$disconnect();
        process.exit(0);
    });
}

/**
 * Handle incoming Pub/Sub message
 * Supports both:
 * 1. GCS Notification Events (New Flow: videos/{id}/source.mp4)
 * 2. MediaUploadedMessage (Old Flow: via UploadService)
 */
async function handleMessage(message: Message): Promise<void> {
    const startTime = Date.now();
    let parsedData: any;

    try {
        parsedData = JSON.parse(message.data.toString());
    } catch (e) {
        logger.error({ error: e, msgId: message.id }, "Failed to parse message data");
        message.nack();
        return;
    }

    // Detect Message Type
    const isGcsEvent = parsedData.kind === "storage#object" && parsedData.name && parsedData.bucket;

    if (isGcsEvent) {
        await handleGcsEvent(message, parsedData);
    } else {
        await handleLegacyMessage(message, parsedData);
    }
}

/**
 * Handler for NEW Flow (GCS Object Finalize)
 */
async function handleGcsEvent(message: Message, data: any): Promise<void> {
    const { name, bucket } = data; // name = "videos/uuid/source.mp4"

    // 1. Filter: Only process 'videos/' or 'images/' folder
    if (!name.startsWith("videos/") && !name.startsWith("images/")) {
        logger.info({ name }, "Ignoring file (path filter)");
        message.ack();
        return;
    }

    // 2. Extract ID
    const parts = name.split("/");
    if (parts.length < 3) {
        logger.warn({ name }, "Invalid path format");
        message.ack();
        return;
    }
    const assetId = parts[1]; // The UUID

    // Special Case: Images
    if (name.startsWith("images/")) {
        // If it's a thumbnail for a video (MediaAsset), we ignore it here 
        // because ContentService updates it directly OR it was generated by us.
        // We only care about "source" images which map to ImageAsset records.
        // Convention: images/{id}/source.jpg|png|webp

        if (name.includes("thumbnail.jpg")) {
            // Likely a video thumbnail, ignore event as DB is updated elsewhere
            message.ack();
            return;
        }

        try {
            // Find ImageAsset
            const imageAsset = await prisma.imageAsset.findUnique({ where: { id: assetId } });

            if (imageAsset && imageAsset.status === MediaAssetStatus.PENDING) {
                await prisma.imageAsset.update({
                    where: { id: assetId },
                    data: {
                        status: MediaAssetStatus.READY,
                        // We can also set the URL here to be sure, though it might be set on creation
                        // url: `https://storage.googleapis.com/${bucket}/${name}` 
                    }
                });
                logger.info({ imageAssetId: assetId }, "ImageAsset marked READY");
            } else {
                logger.info({ imageAssetId: assetId }, "ImageAsset not found or already processed");
            }
        } catch (err) {
            logger.error({ err, assetId }, "Error updating ImageAsset");
        }

        message.ack();
        return;
    }

    // Video Processing (Existing Logic)
    const mediaAssetId = assetId;


    logger.info({ mediaAssetId, name }, "GCS Event received for video");

    try {
        // 3. Idempotency Check & Lock
        const asset = await prisma.mediaAsset.findUnique({ where: { id: mediaAssetId } });

        if (!asset) {
            logger.warn({ mediaAssetId }, "MediaAsset not found in DB. Orphaned file?");
            message.ack(); // Nothing we can do
            return;
        }

        if (asset.status !== MediaAssetStatus.PENDING) {
            logger.info({ mediaAssetId, status: asset.status }, "Asset already processed/processing. Idempotent Skip.");
            message.ack();
            return;
        }

        // Lock: Set to PROCESSING
        await prisma.mediaAsset.update({
            where: { id: mediaAssetId },
            data: { status: MediaAssetStatus.PROCESSING }
        });

        // 4. Processing
        const success = await runTranscodeLogic({
            uploadId: asset.uploadId || "gcs-direct",
            contentId: mediaAssetId,
            contentType: "EPISODE", // Default, or fetch from DB if needed
            sourceUrl: `gs://${bucket}/${name}`,
            sourceBucket: bucket,
            sourceObject: name,
            outputBucket: config.GCS_STREAMING_BUCKET,
            outputPrefix: `hls/${mediaAssetId}`,
        });

        if (success.ok) {
            // 5. Success: Update DB
            await prisma.mediaAsset.update({
                where: { id: mediaAssetId },
                data: {
                    status: MediaAssetStatus.READY,
                    manifestUrl: success.result!.manifestUrl,
                    defaultThumbnailUrl: success.result!.thumbnailUrl || asset.defaultThumbnailUrl
                }
            });
            logger.info({ mediaAssetId }, "DB Updated to READY");

            // 6. Cleanup: Delete source file
            await storage.deleteFile(bucket, name);
        } else {
            // Failure
            await prisma.mediaAsset.update({
                where: { id: mediaAssetId },
                data: { status: MediaAssetStatus.FAILED }
            });
        }

        message.ack();

    } catch (error) {
        logger.error({ error, mediaAssetId }, "Error processing GCS event");
        message.nack(); // Retry
    }
}

/**
 * Handler for OLD Flow (Legacy) - Kept for compatibility
 */
async function handleLegacyMessage(message: Message, msgData: MediaUploadedMessage): Promise<void> {
    const startTime = Date.now();

    try {
        // Skip non-video assets
        if (msgData.assetType !== "video") {
            logger.info({ assetType: msgData.assetType }, "Skipping non-video asset");
            message.ack();
            return;
        }

        // Check contentId, fallback to uploadId if missing
        if (!msgData.contentId) {
            logger.warn({ uploadId: msgData.uploadId }, "Missing contentId, using uploadId as fallback");
            msgData.contentId = msgData.uploadId;
        }

        const { bucket, object } = storage.parseGcsUrl(msgData.storageUrl);
        const outputPrefix = `hls/${msgData.contentId}`;

        logger.info({ uploadId: msgData.uploadId }, "Processing Legacy Job");

        const success = await runTranscodeLogic({
            uploadId: msgData.uploadId,
            contentId: msgData.contentId!,
            contentType: msgData.contentClassification || "REEL",
            sourceUrl: msgData.storageUrl,
            sourceBucket: bucket,
            sourceObject: object,
            outputBucket: config.GCS_STREAMING_BUCKET,
            outputPrefix,
        });

        if (success.ok) {
            // Legacy: Publish event for ContentService to handle DB update
            await publishReadyEvent(msgData, success.result!);

            // Cleanup: Delete source file
            await storage.deleteFile(bucket, object);
        }

        message.ack();

    } catch (error) {
        // ... Error handling simplified for brevity, assume similar to original ...
        logger.error({ error }, "Legacy Job Failed");
        message.nack();
    }
}

/**
 * Core Transcode Logic (Shared)
 */
async function runTranscodeLogic(job: TranscodeJob): Promise<{ ok: boolean, result?: any, error?: any }> {
    try {
        const result = await processTranscodeJob(job);
        return { ok: true, result };
    } catch (error) {
        return { ok: false, error };
    }
}

/**
 * Process a single transcode job
 */
async function processTranscodeJob(job: TranscodeJob): Promise<{
    manifestUrl: string;
    durationSeconds: number;
    renditions: MediaReadyEvent["data"]["renditions"];
    checksum: string;
    thumbnailUrl?: string;
}> {
    // Create unique temp directory for this execution to avoid race conditions
    const executionId = randomUUID();
    const tempDir = join(config.TRANSCODE_TEMP_DIR, executionId);
    const sourcePath = join(tempDir, "source.mp4");
    const outputDir = join(tempDir, "hls");

    try {
        await mkdir(tempDir, { recursive: true });
        await mkdir(outputDir, { recursive: true });

        // Download source video
        logger.info({ job: job.uploadId, sourcePath }, "Downloading source video");
        await storage.downloadSource(job.sourceBucket, job.sourceObject, sourcePath);

        // Verify file exists before transcoding
        const { stat } = await import("node:fs/promises");
        try {
            const stats = await stat(sourcePath);
            logger.info({ sourcePath, size: stats.size }, "Verified source file exists");
        } catch (e) {
            logger.error({ sourcePath, error: e }, "Source file MISSING after download");
            throw e;
        }

        // Transcode to HLS
        logger.info({ job: job.uploadId }, "Starting FFmpeg transcode");
        const result = await ffmpeg.transcode(sourcePath, outputDir, job.contentId);

        // Upload HLS files to GCS
        logger.info({ job: job.uploadId }, "Uploading HLS files to GCS");
        await storage.uploadHlsDirectory(
            outputDir,
            job.outputBucket,
            job.outputPrefix
        );

        // Build final manifest URL
        const manifestUrl = storage.getCdnUrl(`${job.outputPrefix}/master.m3u8`);

        return {
            manifestUrl,
            thumbnailUrl: storage.getCdnUrl(`${job.outputPrefix}/thumbnail.jpg`),
            durationSeconds: result.durationSeconds,
            renditions: result.renditions,
            checksum: result.checksum,
        };
    } finally {
        // Cleanup temp files
        try {
            await rm(tempDir, { recursive: true, force: true });
            logger.debug({ tempDir }, "Cleaned up temp directory");
        } catch (e) {
            logger.warn({ error: e, tempDir }, "Failed to cleanup temp directory");
        }
    }
}

/**
 * Publish media.ready event when transcoding completes
 */
async function publishReadyEvent(
    originalMsg: MediaUploadedMessage,
    result: {
        manifestUrl: string;
        thumbnailUrl?: string;
        durationSeconds: number;
        renditions: MediaReadyEvent["data"]["renditions"];
        checksum: string;
    }
): Promise<void> {
    const readyEvent: MediaReadyEvent = {
        eventId: randomUUID(),
        eventType: "media.ready",
        version: "1.0",
        occurredAt: new Date().toISOString(),
        data: {
            uploadId: originalMsg.uploadId,
            contentId: originalMsg.contentId!,
            contentType: originalMsg.contentClassification || "REEL",
            manifestUrl: result.manifestUrl,
            thumbnailUrl: result.thumbnailUrl,
            durationSeconds: result.durationSeconds,
            renditions: result.renditions,
            checksum: result.checksum,
        },
    };

    const topic = pubsub.topic(config.PUBSUB_READY_TOPIC);
    await topic.publishMessage({ json: readyEvent });

    logger.info(
        { eventId: readyEvent.eventId, contentId: readyEvent.data.contentId },
        "Published media.ready event"
    );
}

// Start the worker
main().catch((error) => {
    logger.fatal({ error }, "Worker failed to start");
    process.exit(1);
});

